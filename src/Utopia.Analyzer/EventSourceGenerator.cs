using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Utopia.Analyzer;

/// <summary>
/// 生成事件的实现
/// </summary>
[Generator]
public class EventSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Utopia.Core";
    private const string AttributeName = "AutoEventImplementAttribute";
    
    private const string AttributeSourceCode = $@"
// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeName} : System.Attribute
    {{
        public {AttributeName}(Type type,string name){{}}
    }}
}}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                                                                      "AutoEventImplementAttribute.g.cs",
                                                                      SourceText.From(AttributeSourceCode, 
                                                                          Encoding.UTF8)));

        var provider = context.SyntaxProvider
                              .CreateSyntaxProvider(
                                                    (s, _) => s is ClassDeclarationSyntax,
                                                    (ctx, _) => GetClassDeclarationForSourceGen(ctx));

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
                                     ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }
    
    /// <summary>
    /// Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static IEnumerable<(ClassDeclarationSyntax,TypeOfExpressionSyntax,string name)> GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        List<(ClassDeclarationSyntax,TypeOfExpressionSyntax, string name)> output = [];
        
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName != $"{Namespace}.{AttributeName}")
                continue;

            var accesses = attributeSyntax.ArgumentList?.DescendantNodes().OfType<TypeOfExpressionSyntax>();
            
            foreach(var @typeof in accesses ?? [])
            foreach(var memberAccess in @typeof.DescendantNodes().OfType<LiteralExpressionSyntax>())
            {
                var accessName = memberAccess.GetText(Encoding.UTF8).ToString()!;
                
                output.Add(new(
                               classDeclarationSyntax,
                               @typeof,
                               accessName.Substring(1,accessName.Length - 2)));
            }
        }

        return output;
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
                              ImmutableArray<IEnumerable<(ClassDeclarationSyntax,TypeOfExpressionSyntax,string name)>> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach(var singleFileDeclarations in classDeclarations)
        foreach (var classDeclarationSyntax in singleFileDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.Item1.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax.Item1) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Item1.Identifier.Text;

            var retType = classDeclarationSyntax.Item2.Type.GetText(Encoding.UTF8).ToString();

            var rawType =
                retType
                    .Replace("Action", string.Empty)
                    .Replace("<", string.Empty)
                    .Replace(">", string.Empty);

            // Build up the source code
            var code = $@"
// <auto-generated/>

using System;
using System.Collections.Generic;
using Utopia.Core;

namespace {namespaceName};

partial class {className}
{{
    protected WeakThreadSafeEventSource<{rawType}> {classDeclarationSyntax.name}Source = new();

    public event Action<{retType}> {classDeclarationSyntax.name} {{
        add => {classDeclarationSyntax.name}Source.Register(value);
        remove => {classDeclarationSyntax.name}Source.Unregister(value);
    }}
}}
";
            // Add the source code to the compilation.
            context.AddSource($"{className}-{classDeclarationSyntax.name}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}